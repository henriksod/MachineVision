# -*- coding: utf-8 -*-
"""
The following program uses:
* PyWavefront
* Pyglet (remove?)
* Numpy
* Scipy
* Matplotlib

"""

import sys
sys.path.append('..')
import ctypes

import os

import pyglet
from pyglet.gl import *
from pywavefront import Wavefront
from pywavefront import ObjParser

import math
import numpy as np
import matplotlib.pyplot as plt
from scipy import ndimage
from scipy import misc
from numpy.linalg import inv

from segment import Segmenting

def meanVertex(verticesArr):
    """
    Get the mean vertex from an array of vertices.
    
    Only accepts column vectors (1x3).
    
    Keyword arguments:
    verticesArr -- the array of vertices (represented by columns)
    """
    
    mean_x = np.mean(verticesArr[0,:])
    mean_y = np.mean(verticesArr[1,:])
    mean_z = np.mean(verticesArr[2,:])
    
    return np.array([mean_x, mean_y, mean_z])

def longestVectorIndex(verticesArr):
    """
    Get the vertex from an array of vertices that is has the
    longest distance from the origin.
    
    Only accepts column vectors (1x3).
    
    Keyword arguments:
    verticesArr -- the array of vertices (represented by columns)
    """
    
    mem_size = int(len(verticesArr[0,:]))
    distances = np.empty([mem_size], dtype=float)
    
    for x in range(0,len(verticesArr[0,:])):
        distances[x] = np.sqrt(verticesArr[:,x].dot(verticesArr[:,x]))
    
    return np.argmax(distances)

def initVertices(mesh, verticesArr):
    """
    Extracts the vertex compoent from an array generated by
    the PyWavefront library, the structure is [TTNNNVVVTTNNNVVV...]
    where T = Texture coordinate, N = Normal coordinate and
    V = Vertex coordinate.
    
    Keyword arguments:
    mesh -- the array created by PyWavefront, structure [TTNNNVVVTTNNNVVV...]
    verticesArr -- the array of vertices to generate, should be
                   pre-allocated as a Nx3 array.
    """
    
    i = 0
    for x in range(5,len(mesh),8):
        verticesArr[0, i] = mesh[x]
        verticesArr[1, i] = mesh[x+1]
        verticesArr[2, i] = mesh[x+2]
        i += 1

def rotationTo(vec1, vec2):
    """
    Extracts the rotation matrix describing the rotation from one
    vector to another.
    
    Only accepts column vectors (1x3).
    
    Keyword arguments:
    vec1 -- the vector to rotate from (column vector)
    vec2 -- the vector to rotate to (column vector)
    """
    
    v = np.cross(vec1, vec2)
    s = np.sqrt(v.dot(v))
    c = vec1.dot(vec2)

    skewSymmV = np.matrix([[0,-v[2],v[1]],
                           [v[2],0,-v[0]],
                           [-v[1],v[0],0]])
    
    return np.transpose(np.identity(3) + skewSymmV + (skewSymmV.dot(skewSymmV))/(1+c))

def rotate(v, R):
    """
    Rotates all vectors in a Nx3 array according to a
    rotation matrix.
    
    Only accepts column vectors (1x3).
    
    Keyword arguments:
    v -- Nx3 array of vectors (or vertices)
    R -- 3x3 rotation matrix
    """
    
    for x in range(0,len(v[0, :])):
        v[:, x] = R.dot(v[:, x])
        
def translate(vs, v):
    """
    Translates all vectors in a Nx3 array according to a
    translation vector.
    
    Only accepts column vectors (1x3).
    
    Keyword arguments:
    vs -- Nx3 array of vectors (or vertices)
    v -- 1x3 translation vector
    """
    
    vs[0, :] = vs[0, :] - v[0]
    vs[1, :] = vs[1, :] - v[1]
    vs[2, :] = vs[2, :] - v[2]
    
def rotateMesh(m, R):
    """
    Rotates the PyWavefront mesh according to a
    rotation matrix.
    
    Keyword arguments:
    m -- PyWavefront mesh vertices component [TTNNNVVV...]
    R -- 3x3 rotation matrix
    """
    
    for x in range(5,len(m),8):
        v = np.transpose(R.dot(np.transpose(m[x:x+3])))
        m[x] = v[0]
        m[x+1] = v[1]
        m[x+2] = v[2]
        
def translateMesh(m, v):
    """
    Translates the PyWavefront mesh according to a
    translation vector.
    
    Only accepts column vectors (1x3).
    
    Keyword arguments:
    m -- PyWavefront mesh vertices component [TTNNNVVV...]
    v -- 1x3 translation vector
    """
    
    for x in range(5,len(m),8):
        m[x] = m[x] - v[0]
        m[x+1] = m[x+1] - v[1]
        m[x+2] = m[x+2] - v[2]
                   
#####################################################
                   
rotation = 0

argLen = len(sys.argv)
argList = sys.argv

objPath = ''
imagePath = ''
precision = 50

if argLen == 4:
    objPath = argList[1]
    imagePath = argList[2]
    precision = int(argList[3])
    
print('Welcome! I like finding blob distrubutions from 3d egg models. Feed me!')
    
pathToHere = os.path.dirname(os.path.realpath(__file__))
if objPath[0] == '.':
    objPath = pathToHere + objPath[1:]
if imagePath[0] == '.':
    imagePath = pathToHere + imagePath[1:]

print('Loading egg...')
    
meshes = Wavefront(objPath)
vertices = meshes.materials['egg_model'].vertices

print('Done')

print('Translating and rotating egg...')

mem_size = int(len(vertices)/8)
          
vertices_only = np.empty([3, mem_size], dtype=float)

initVertices(vertices, vertices_only)

mean_arr = meanVertex(vertices_only)

translate(vertices_only, mean_arr)

maxIndexTop = longestVectorIndex(vertices_only)

maxVectorTop = np.copy(vertices_only[:,maxIndexTop])
    
translate(vertices_only, maxVectorTop)
translateMesh(vertices, mean_arr+maxVectorTop)

maxIndexBottom = longestVectorIndex(vertices_only)

maxVectorBottom = vertices_only[:,maxIndexBottom]

#https://math.stackexchange.com/questions/180418/calculate-rotation-matrix-to-align-vector-a-to-vector-b-in-3d?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa
dir0 = np.transpose([0,0,1])
dirEgg = maxVectorBottom/np.sqrt(maxVectorBottom.dot(maxVectorBottom))
    
R = rotationTo(dir0, dirEgg)

rotate(vertices_only, R)
rotateMesh(vertices, R)

print('Done')

print('Segmenting the egg model...')

segmenting = Segmenting(precision, vertices)

texture = misc.imread(imagePath) # texture[0,0] = [83 44 37] = [ R G B ], texture :: ndarray
segmenting.pairWithTexture(texture)

print('Done')

print('Generating histogram...')

histBin = []
for i in range(0, len(segmenting.segments)):
    for j in range(0, len(segmenting.segments[i])):
        color = segmenting.colorDict[(i,j)]
        if segmenting.isBlob(color):
            histBin.append(i)
    
# Create histogram
# the histogram of the data
n, bins, patches = plt.hist(histBin, precision, facecolor='g')

plt.xlabel('Top to Bottom')
plt.ylabel('Frequency')
plt.title('Histogram of Blob Distribution')
plt.grid(True)
plt.show()

print('Done')

print('We are done here. Bye!')

sys.exit()
   
# PYGLET ------------------------------------------------------------------------
"""
window = pyglet.window.Window(1024, 720, caption = 'Demo', resizable = True)

lightfv = ctypes.c_float * 4
label = pyglet.text.Label('Hello, world', font_name = 'Times New Roman', font_size = 12, x = 800, y = 700, anchor_x = 'center', anchor_y = 'center')
    
def drawLine(pt1, pt2, color, scale):
    pyglet.graphics.draw(2,
                         pyglet.gl.GL_LINES,
                         ('v3f', (pt1[0], pt1[1], pt1[2], pt2[0]*scale, pt2[1]*scale, pt2[2]*scale)),
                         ('c3B', (color[0], color[1], color[2], color[0], color[1], color[2])))

@window.event
def on_resize(width, height):
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(40.0, float(width)/height, 1, 100.0)
    glEnable(GL_DEPTH_TEST)
    glMatrixMode(GL_MODELVIEW)
    return True

@window.event
def on_draw():
    window.clear()
    glLoadIdentity()
    glLightfv(GL_LIGHT0, GL_POSITION, lightfv(-40, 200, 100, 0.0))
    glLightfv(GL_LIGHT0, GL_AMBIENT, lightfv(0.2, 0.2, 0.2, 1.0))
    glLightfv(GL_LIGHT0, GL_DIFFUSE, lightfv(0.5, 0.5, 0.5, 1.0))
    glEnable(GL_LIGHT0)
    glEnable(GL_LIGHTING)
    glEnable(GL_COLOR_MATERIAL)
    glEnable(GL_DEPTH_TEST)
    glShadeModel(GL_SMOOTH)
    glMatrixMode(GL_MODELVIEW)
    glTranslated(0, .8, -20)
    glRotatef(-66.5, 0, 0, 1)
    glRotatef(rotation, 1, 0, 0)
    glRotatef(90, 0, 0, 1)
    glRotatef(0, 0, 1, 0)
    pyglet.graphics.draw(2,pyglet.gl.GL_LINES,('v3f', (-maxVectorBottom[0]*5, -maxVectorBottom[1]*5, -maxVectorBottom[2]*5,maxVectorBottom[0]*5, maxVectorBottom[1]*5, maxVectorBottom[2]*5)))
    
    drawLine([0,0,0], [1,0,0], [255,0,0], 5)
    drawLine([0,0,0], [0,1,0], [0,255,0], 5)
    drawLine([0,0,0], [0,0,1], [0,0,255], 5)
    
    meshes.draw()

def update(dt):
    #return 0
    global rotation
    rotation += 45 * dt
    if rotation > 720: 
        rotation = 0

pyglet.clock.schedule(update)

pyglet.app.run()
"""